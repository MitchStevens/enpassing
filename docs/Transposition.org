#+TITLE: Transposition

* Semitone Objects
Semitone objects are sets with an instances of Semitones defined.
#+begin_src haskell
class Semitones t where
  steps :: t -> Int
#+end_src

This instance also defines a relation
#+begin_src
s ~ t <=> mod12 (steps s) = mod12 (steps t)

reflexive y
symmetric y
transitive

assume s ~ t and t ~ u
steps s = mod12 (steps t)
        = mod12 (mod12 (steps u)) -- mod12 is idem.
        = mod12 (steps u)
thus s ~ u
#+end_src

~steps~ should also define a partial ordering

#+begin_src haskell
compare a b
  | a == b = Just EQ
  | a < b  = Just LT
  | a > b  = Just GT
  | otherwise = Nothing
#+end_src

* Transposable Objects
A transposable object is a type with an instance of ~Transpose~.
#+begin_src haskell
transpose :: Transpose t => Int -> t -> t
#+end_src

We can define a group operations (identity, addition, inverse) for any Semitone and Transposable object if we have a valid identity element.
#+begin_src
s + t = transpose (steps t) s
- s = transpose (- steps s) 0
#+end_src

For this object to be a group, we need to prove:
#+begin_src
0 element exists            identity
(s+t)+u = s+(t+u)           associativity
a+(-a) = (-a)+a = 0         inverse
#+end_src

The set of functions ~{transpose n | n in Z}~ should also form a group
#+begin_src
0 = transpose 0
transpose m + transpose n = transpose (m+n)
- transpose n = transpose (-n)
#+end_src

* Transposition Property
We need to relate the ~Semitones~ and ~Transpose~ classes. This is called the *transposition property*:
~steps (transpose n t) = steps t + n~.

The *transposition property* holds whenever ~steps~ is surjective. Proof:
#+begin_src haskell
    = steps (transpose n t)
    = steps (transpose (steps s) t) -- steps is surjective,

-- let n' be an value such that
                                 -- steps n' = n
    = steps (t + n')
    = steps t + steps n'
    = steps t + n
#+end_src

There is also a *weak transposition property*:
~mod12 (steps n t) = mod12 (steps t + n)~
TODO: When does this hold? When ~mod12 . steps~ is surjective???

* Back into the real world
We also want to transpose by an interval. An interval contains the number of semitones to transpose by, but also contains information about how the note should be spelled enharmonically.

#+begin_src
shift A4 C = F#
shift D5 C = Gb
#+end_src

So lets define transpose in terms of another function
#+begin_src haskell
class Transpose t where
  shift :: Interval -> t -> t

transpose :: Transpose t => Int -> t -> t
transpose = shift . stepsToInterval
#+end_src
